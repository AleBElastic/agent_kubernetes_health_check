****** List of tools to Create ******

# Create the Agent 
POST kbn://api/agent_builder/agents
{
      "id": "systemhealth",
      "type": "chat",
      "name": "Kubernetes Deployment Analyser",
      "description": "Helping you analyse Kubernetes Environment issue",
      "labels": [],
      "avatar_color": "",
      "avatar_symbol": "",
      "configuration": {
        "instructions": """# ROLE AND OBJECTIVE
You are KubeSentinel, an expert Kubernetes Reliability Engineer and AI Agent specialized in cluster health analysis. Your goal is to analyze Kubernetes deployments and act as a tool to identifying issues, root causes, and optimization opportunities.

You operate in three distinct modes (Tools). When a user provides you with a question,  you must dynamically select the appropriate tool strategy from the list below to provide a structured analysis.

---

# CORE TOOLS & ANALYSIS PROTOCOLS

### TOOL 1: DEPLOYMENT HEALTH CHECK
**find_deployment_issues**
This tool allows you to find issues in your deployments like understanding if there are deployments that currently have replicas not created, restarts, or memory or cpu issues
**Goal:** Identify failed or degrading deployments.
**Output Format:**
- **Status:** [CRITICAL / WARNING / HEALTHY]
- **Affected Workloads:** List specific deployment/pod names.
- **Diagnosis:** A 1-sentence explanation of *why* it is failing.

### TOOL 2: ERROR LOG
**find_error_logs**: Which retrieves deployments with errors in their logs

### TOOL 3: RESOURCE OPTIMIZATION
**suggest_optimisation:**  Recommend better resource allocation to prevent throttling or waste.
**Output Format:**
- **Current Configuration:** (e.g., Request: 1Gi, Limit: 2Gi)
- **Observed Usage:** (e.g., 200Mi)
- **Recommendation:** specific YAML snippet with adjusted values

---

# RESPONSE GUIDELINES
1.  **No Fluff:** Do not be conversational. Go straight to the analysis.
2.  **Structured Output:** Always use Markdown headers and bullet points.
3.  **Action Oriented:** Every finding must be accompanied by a specific `kubectl` command or YAML fix the user can apply immediately.
4.  **Unknowns:** If you lack sufficient data to use a tool (e.g., analyzing logs without log data), explicitly ask for the missing command output (e.g., "Please provide output of `kubectl logs <pod-name>`").""",
        "tools": [
          {
            "tool_ids": [
              "platform.core.list_indices",
              "platform.core.get_document_by_id",
              "find_deployment_issues",
              "find_error_logs",
              "suggest_optimisation",
              "platform.core.get_index_mapping"
            ]
          }
        ]
      },
      "readonly": false
    }

# Create the tools

POST kbn://api/agent_builder/tools
{
  "id": "find_deployment_issues",
  "type": "esql",
  "description": "This tool allows you to find issues in your deployments like understanding if there are deployments that currently have replicas not created, restarts, or memory or cpu issues",
  "tags": [],
  "configuration": {
    "query": """FROM metrics-k8sclusterreceiver.otel-default, metrics-kubeletstatsreceiver.otel-default
| WHERE @timestamp > NOW() - 1 hour
| EVAL has_issue = CASE(
    k8s.deployment.available < k8s.deployment.desired, 1,
    k8s.container.restarts > 3, 1,
    k8s.container.ready == 0, 1,
    k8s.container.memory_limit_utilization > 0.9, 1,
    k8s.container.cpu_limit_utilization > 0.9, 1,
    0
  )
| WHERE has_issue == 1
| KEEP @timestamp, resource.attributes.k8s.namespace.name, resource.attributes.k8s.deployment.name, 
       resource.attributes.k8s.pod.name, resource.attributes.k8s.container.name, 
       k8s.container.ready, k8s.container.restarts, k8s.deployment.available, 
       k8s.deployment.desired, k8s.container.memory_limit_utilization, 
       k8s.container.cpu_limit_utilization, has_issue
| STATS 
    latest_timestamp = MAX(@timestamp),
    latest_ready = TOP(k8s.container.ready, 1, "desc"),
    latest_restarts = TOP(k8s.container.restarts, 1, "desc"),
    latest_available = TOP(k8s.deployment.available, 1, "desc"),
    latest_desired = TOP(k8s.deployment.desired, 1, "desc"),
    latest_memory_util = TOP(k8s.container.memory_limit_utilization, 1, "desc"),
    latest_cpu_util = TOP(k8s.container.cpu_limit_utilization, 1, "desc")
  BY 
    resource.attributes.k8s.namespace.name,
    resource.attributes.k8s.deployment.name,
    resource.attributes.k8s.pod.name,
    resource.attributes.k8s.container.name
| SORT latest_restarts ASC
| LIMIT 100""",
    "params": {}
  },
  "readonly": false,
  "schema": {
    "type": "object",
    "properties": {},
    "additionalProperties": false,
    "description": "Parameters needed to execute the query",
    "$schema": "http://json-schema.org/draft-07/schema#"
  }
}

POST kbn://api/agent_builder/tools/find_error_logs
 {
      "id": "find_error_logs",
      "type": "esql",
      "description": """find_error_logs: Find logs with error in my kubernetes deployment

""",
      "tags": [],
      "configuration": {
        "query": """FROM logs-*
| WHERE @timestamp > NOW() - 1 hour
| WHERE log.level == "ERROR" OR severity_text == "ERROR" OR message LIKE "*ERROR*"
| KEEP @timestamp, message, resource.attributes.k8s.pod.name, resource.attributes.k8s.namespace.name, resource.attributes.k8s.container.name, log.level, severity_text
| STATS latest_timestamp = MAX(@timestamp), latest_message = TOP(message, 1, "desc") BY resource.attributes.k8s.container.name
| SORT latest_timestamp DESC
| LIMIT 100""",
        "params": {}
      },
      "readonly": false
    }

POST kbn://api/agent_builder/tools/suggest_optimisation
{
      "id": "suggest_optimisation",
      "type": "esql",
      "description": "Recommend better resource allocation to prevent throttling or waste.",
      "tags": [],
      "configuration": {
        "query": """FROM metrics-*
| WHERE @timestamp >= NOW() - 7 days
| WHERE k8s.namespace.name == ?namespace AND (k8s.container.memory_request_utilization IS NOT NULL OR k8s.container.cpu_request_utilization IS NOT NULL)
| STATS 
    avg_cpu_util = AVG(k8s.container.cpu_request_utilization)* 100,
    max_cpu_util = MAX(k8s.container.cpu_request_utilization)* 100,
    p95_cpu_util = PERCENTILE(k8s.container.cpu_request_utilization, 95) * 100,
    avg_mem_percent = AVG(k8s.container.memory_request_utilization)* 100,
    max_mem_percent = MAX(k8s.container.memory_request_utilization)* 100,
    p95_mem_percent = PERCENTILE(k8s.container.memory_request_utilization, 95) * 100
  BY kubernetes.namespace, kubernetes.container.name
| EVAL 
    cpu_recommendation = CASE(
      avg_cpu_util < 30, "Underutilized - Consider reducing CPU requests/limits",
      avg_cpu_util > 80, "Overutilized - Consider increasing CPU requests/limits",
      "Appropriately sized"
    ),
    mem_recommendation = CASE(
      avg_mem_percent < 30, "Underutilized - Consider reducing memory requests/limits",
      avg_mem_percent > 80, "Overutilized - Consider increasing memory requests/limits",
      "Appropriately sized"
    ),
    throttling_risk = CASE(
      max_cpu_util > 90, "High risk of CPU throttling",
      p95_cpu_util > 80, "Medium risk of CPU throttling",
      "Low risk of CPU throttling"
    ),
    oom_risk = CASE(
      max_mem_percent > 90, "High risk of OOM kills",
      p95_mem_percent > 80, "Medium risk of OOM kills",
      "Low risk of OOM kills"
    )
| SORT avg_cpu_util DESC
| LIMIT 100""",
        "params": {
          "namespace": {
            "type": "text",
            "description": "This is the namespace where the pods are failing or for my applications ",
            "optional": false
          }
        }
      },
      "readonly": false
    }
